## 8. 자바스크립트의 객체는 `참조에 의해 복사`됩니다. 이로 인해 생길 수 있는 오류와, 해당 오류를 피하는 방법을 설명해주세요.

- 답변)
  - 의도: `참조에 의한 접근`과 `값에 의한 접근`을 구분할 수 있는지 확인하는 질문입니다.
  - 팁: 객체를 참조가 아닌 값으로서 복사하는 방법도 소개하면 좋습니다.
  - 모범 답안: 네, 여기서 참조에 의한 복사가 일어나는 이유는 값 자체를 복사해 주는 게 아니라 `값이 들어있는 메모리 주소를 복사`해서 주기 때문입니다. 그렇기에 객체를 복사하게 되면 서로 같은 메모리 주소를 가리키게 되어 한쪽이 값을 바꾸면 다른 쪽이 보여주는 값도 바뀌게 되는 겁니다. 이러한 특징 때문에 여러 오류가 생기곤 합니다. 그래서 깊은 복사를 통해 객체 또한 값으로서 복사하도록 하는 방법들이 있는데 대표적으로는 `JSON.stringify()`를 통해 객체를 문자열로 바꾸어서 복사하는 방법이 있고, 비교적 최근에 나온 `structuredClone()`을 사용하는 방법이 있습니다. 개인적으로는 후자가 더 짧고 쉽기 때문에 더 애용하는 편입니다.

### JSON.stringify() 단점

JSON.stringify()를 사용하여 객체를 복사하는 방법은 간편하지만 몇 가지 단점이 있습니다. 주요 단점은 다음과 같습니다:

  <br/>

#### 1. 함수 및 메서드 손실

- JSON.stringify()는 함수(메서드)를 포함한 객체를 복사할 수 없습니다. 함수는 JSON 형식에 포함되지 않기 때문에 복사된 객체에서 해당 메서드는 사라집니다.

  <br/>

#### 2. 순환 참조 처리 불가

- 객체에 순환 참조가 포함되어 있을 경우, JSON.stringify()는 오류를 발생시킵니다. 예를 들어, 객체가 자기 자신을 참조하는 경우 JSON으로 변환할 수 없습니다.

  <br/>

#### 3. 특정 데이터 타입 손실

- Date 객체, Map, Set, undefined, Infinity, NaN 등과 같은 특정 데이터 타입은 JSON으로 변환할 때 적절하게 처리되지 않으며, 변환 후 기본형(예: Date는 문자열로 변환됨)으로 바뀌거나 손실됩니다.

  <br/>

#### 4. 프로토타입 체인 손실

- JSON.stringify()는 객체의 프로토타입 체인을 무시하고 단순한 객체만을 복사합니다. 따라서 객체의 메서드나 상속받은 속성은 복사된 객체에 포함되지 않습니다.

  <br/>

#### 5. 속성의 순서

- 객체의 속성 순서는 보장되지 않습니다. JSON 객체의 속성 순서는 기본적으로 정렬되지 않기 때문에, 복사된 객체의 속성 순서가 원본과 다를 수 있습니다.

  <br/>

#### 6. 성능 문제

- 복사할 객체가 매우 클 경우, JSON.stringify()와 JSON.parse()를 사용하는 것은 성능에 영향을 줄 수 있습니다. 특히, 깊이가 깊거나 속성이 많은 객체를 다룰 때 성능 저하가 발생할 수 있습니다.
  이러한 이유로, JSON.stringify()를 사용한 객체 복사는 간단한 경우에는 유용하지만, 복잡한 객체를 다룰 때는 다른 방법(예: Object.assign() 또는 스프레드 연산자 등)을 고려해야 합니다.

## 객체 깊은 복사 비교

### 1. structuredClone()

#### 장점

- 깊은 복사: 중첩된 객체 및 배열을 포함한 모든 데이터 타입(함수 제외)을 깊게 복사합니다.
- 순환 참조 처리: 순환 참조가 있는 객체를 복사할 수 있습니다.
- 고급 데이터 타입 지원: Date, Map, Set, ArrayBuffer 등 다양한 데이터 타입을 지원합니다.

#### 단점

- 브라우저 지원: 모든 브라우저에서 지원되지 않으며, Node.js 환경에서도 사용할 수 있습니다.
- 성능: 복사할 객체가 크거나 복잡할 경우 성능에 영향을 줄 수 있습니다.

<br />

### 2. Object.assign()

#### 장점

- 얕은 복사: 간단한 객체 복사에 적합합니다.
- 브라우저 호환성: 대부분의 환경에서 지원됩니다.

#### 단점

- 얕은 복사: 중첩된 객체는 참조로 복사되므로, 원본 객체의 중첩된 속성을 수정하면 복사된 객체에도 영향을 미칩니다.
- 함수 복사 불가: 메서드는 복사되지 않습니다.

![비교 표](./img/스크린샷%202024-08-06%20오후%201.11.27.png)

# 8. 자바스크립트의 객체는 참조에 의해 복사됩니다. 이로 인해 생길 수 있는 오류와, 해당 오류를 피하는 방법을 설명해주세요.

`의도: 참조에 의한 접근과 값에 의한 접근을 구분`

자바스크립트에서 객체는 참조에 의한 복사가 되는데,
그 이유는 값 자체를 복사하는 것이 아니라 값이 들어있는 `메모리 주소`를 복사하기 때문.

그러니 객체를 복사하게 되면 서로 같은 메모리 주소를 가리키게 되어 한쪽의 값을 바꾸면
다른 쪽이 보여주는 값도 영향을 받아 함께 변경됨.

그렇기에 `깊은 복사`를 통해 객체 또한 값으로서 복사하는 방법을 사용함.

대표적인 방법으로 `JSON.stringify()`를 통해 객체를 문자열로 바꾸어 복사하는 방법이 있고(간단하고 직관적이지만, 함수와 `undefined`값은 복사되지 않음),
비교적 최근에 나온 `structuredClone()`을 사용하는 방법이 있음(`undefined`를 제회한 모든 데이터 유형을 정확히 복사하지만 최신 브라우저에서만 지원.)

```jsx
// 1. JSON 방법
let obj1 = { a: 1 };
let obj2 = JSON.parse(JSON.stringify(obj1));

obj2.a = 2;
console.log(obj1.a); // 1

// 2. structuredClone 방법
let obj1 = { a: 1 };
let obj2 = structuredClone(obj1);

obj2.a = 2;
console.log(obj1.a); // 1
```

`Lodash`라이브러리를 사용하는 방법도 있는 `_.cloneDeep`메서드를 사용하여 깊을 복사를 할 수 있다.

```jsx
let obj1 = { a: 1 };
let obj2 = _.cloneDeep(obj1);

obj2.a = 2;
console.log(obj1.a); // 1
```

복잡한 구조의 객체도 정확하게 깊은 복사 할 수 있지만, 외부 라이브러리를 사용한다는 것이 단점일 수 있다.
